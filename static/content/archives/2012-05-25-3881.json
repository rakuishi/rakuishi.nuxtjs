{
  "categories": [
    "iOS"
  ],
  "date": "2012-05-24T23:00:46.000Z",
  "draft": false,
  "slug": 3881,
  "title": "[iOS SDK] ネット上の画像を表示させた UITableView をぬるぬる動作させる方法",
  "bodyContent": "![](/images/2012/05/3881_1.png)\n\nUITableView の Cell に、ネットから取得した画像を表示したい場合（上図）、次のようなコードになると思います（ARC で書いています）。\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString *CellIdentifier = @\"Cell\";\n    \n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];\n    }\n\n    cell.textLabel.text = @\"rakuishi07\";\n\n    NSString *imageURL = @\"http://rakuishi.com/wp-content/themes/rakuishi/image/rakuishi.png\";\n    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL: [NSURL URLWithString: imageURL]]];\n    cell.imageView.image = image;\n    \n    return cell;\n}\n```\n\nこれで動くっちゃ動くのですが、テーブルビューを動かしている時に画像ロードが発生して、操作がカクついてしまうので、あまりよろしくないです（カクついている時、ビーチボールを連想します）。\n\nこういう時は、GCD の非同期通信を使用して、Blocks との組み合わせ技を使うと、テーブルビューがぬるぬるになるようです。\n\n慣れるために、簡単なコードを書いてみました。\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString *CellIdentifier = @\"Cell\";\n    \n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];\n    }\n\n    cell.textLabel.text = @\"rakuishi07\";\n\n    dispatch_queue_t q_global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_queue_t q_main = dispatch_get_main_queue();\n\n    cell.imageView.image = nil;\n    \n    dispatch_async(q_global, ^{\n        NSString *imageURL = @\"http://rakuishi.com/wp-content/themes/rakuishi/image/rakuishi.png\";\n        UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL: [NSURL URLWithString: imageURL]]];\n        \n        dispatch_async(q_main, ^{            \n            cell.imageView.image = image;\n            [cell layoutSubviews];\n        });\n    });\n    \n    return cell;\n}\n```\n\nこのコードで動作させると先程までかくかくしていたのが、ぬるぬるになります。\n\nこれを基本に、読み込みまでインジケータを表示させたり、画像キャッシュを利用する（今のままでは、スクロールするたびに新しく読み込んでしまう）ためにどうすればいいかこれから勉強していこうと思います。\n\n## 参考\n\n* [並列プログラミングガイド](https://developer.apple.com/jp/devcenter/ios/library/documentation/ConcurrencyProgrammingGuide.pdf)\n* [ASCII.jp：マルチコア時代の新機軸！ Snow LeopardのGCD｜もっと知りたい！ Snow Leopard](http://ascii.jp/elem/000/000/455/455786/)\n* [iOS4でGCDとBlocksを使ってUITableViewへの非同期画像読み込みを書いてみる。 - Paamayim Nekudotayim](http://d.hatena.ne.jp/craccho/20100711/1278837199)",
  "bodyHtml": "<p><img src=\"/images/2012/05/3881_1.png\" alt=\"\"></p>\n<p>UITableView の Cell に、ネットから取得した画像を表示したい場合（上図）、次のようなコードになると思います（ARC で書いています）。</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString *CellIdentifier = @&quot;Cell&quot;;\n    \n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];\n    }\n\n    cell.textLabel.text = @&quot;rakuishi07&quot;;\n\n    NSString *imageURL = @&quot;http://rakuishi.com/wp-content/themes/rakuishi/image/rakuishi.png&quot;;\n    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL: [NSURL URLWithString: imageURL]]];\n    cell.imageView.image = image;\n    \n    return cell;\n}\n</code></pre>\n<p>これで動くっちゃ動くのですが、テーブルビューを動かしている時に画像ロードが発生して、操作がカクついてしまうので、あまりよろしくないです（カクついている時、ビーチボールを連想します）。</p>\n<p>こういう時は、GCD の非同期通信を使用して、Blocks との組み合わせ技を使うと、テーブルビューがぬるぬるになるようです。</p>\n<p>慣れるために、簡単なコードを書いてみました。</p>\n<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString *CellIdentifier = @&quot;Cell&quot;;\n    \n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];\n    }\n\n    cell.textLabel.text = @&quot;rakuishi07&quot;;\n\n    dispatch_queue_t q_global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_queue_t q_main = dispatch_get_main_queue();\n\n    cell.imageView.image = nil;\n    \n    dispatch_async(q_global, ^{\n        NSString *imageURL = @&quot;http://rakuishi.com/wp-content/themes/rakuishi/image/rakuishi.png&quot;;\n        UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL: [NSURL URLWithString: imageURL]]];\n        \n        dispatch_async(q_main, ^{            \n            cell.imageView.image = image;\n            [cell layoutSubviews];\n        });\n    });\n    \n    return cell;\n}\n</code></pre>\n<p>このコードで動作させると先程までかくかくしていたのが、ぬるぬるになります。</p>\n<p>これを基本に、読み込みまでインジケータを表示させたり、画像キャッシュを利用する（今のままでは、スクロールするたびに新しく読み込んでしまう）ためにどうすればいいかこれから勉強していこうと思います。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://developer.apple.com/jp/devcenter/ios/library/documentation/ConcurrencyProgrammingGuide.pdf\">並列プログラミングガイド</a></li>\n<li><a href=\"http://ascii.jp/elem/000/000/455/455786/\">ASCII.jp：マルチコア時代の新機軸！ Snow LeopardのGCD｜もっと知りたい！ Snow Leopard</a></li>\n<li><a href=\"http://d.hatena.ne.jp/craccho/20100711/1278837199\">iOS4でGCDとBlocksを使ってUITableViewへの非同期画像読み込みを書いてみる。 - Paamayim Nekudotayim</a></li>\n</ul>\n",
  "dir": "static/content/archives",
  "base": "2012-05-25-3881.json",
  "ext": ".json",
  "sourceBase": "2012-05-25-3881.md",
  "sourceExt": ".md"
}