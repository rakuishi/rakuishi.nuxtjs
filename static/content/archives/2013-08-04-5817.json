{
  "categories": [
    "cocos2d-x"
  ],
  "date": "2013-08-03T15:31:59.000Z",
  "draft": false,
  "slug": 5817,
  "title": "cocos2d-x で Objective-C / Java のコードを実行する",
  "bodyContent": "マルチプラットフォーム開発できる cocos2d-x で、iOS の Objective-C、Android の Java のコードを実行する方法を紹介します。\n\nここでは、ログを出力させるコードをネイティブで書きます。ログを出力するコードは、iOS なら AppController.m、Android なら MyProject.java に記述し、それをコールする処理を想定しています。\n\n## 作成するファイル\n\n以下のファイルを プロジェクト名/Classes に作成します。\n\n* NativeLauncher.h（iOS, Android 共通）\n* NativeLauncher.mm（iOS）\n* NativeLauncher.cpp（Android）\n\n![](/images/2013/08/5817_1.png)\n\n## iOS 及び Android 共通の作業\n\nNativeLauncher.h を作成し、以下の内容を記述します。返り値 void で、引数を必要としない launchNative() クラスを宣言します。\n\n```\n// NativeLauncher.h\n\n#ifndef MyProject_NativeLauncher_h\n#define MyProject_NativeLauncher_h\n\nclass NativeLauncher\n{\npublic:\n    static void launchNative();\n};\n\n#endif\n```\n\nNativeLauncher.h で宣言したクラスを HelloWorldScene.cpp から呼び出すように追加します。標準で作成される HelloWorldScene.cpp の menuCloseCallback に記述します。これで、ボタンが押されるたびにログが吐かれるようになります。\n\n```\n// HelloWorldScene.cpp\n\nvoid HelloWorld::menuCloseCallback(CCObject* pSender)\n{\n    NativeLauncher::launchNative();\n    \n    /*\n    CCDirector::sharedDirector()->end();\n\n#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n    exit(0);\n#endif\n     */\n}\n```\n\n## iOS 側で行う作業（Xcode）\n\nプロジェクト名/proj.ios/プロジェクト名.xcodeproj を Xcode で起動します。\n\nAppController.h および AppController.m にログを吐き出すだけのメソッドを追加します。\n\n```\n// AppController.h\n\n#import <UIKit/UIKit.h>\n\n@class RootViewController;\n\n@interface AppController : NSObject <UIApplicationDelegate> {\n    UIWindow *window;\n    RootViewController    *viewController;\n}\n\n- (void)launchNative; // 追加\n\n@end\n```\n\n```\n// AppController.m\n\n// ...\n\n- (void)launchNative\n{\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n// ...\n```\n\nこちらを cocos2d-x から呼び出すために、NativeLauncher.mm を作成し、以下の内容を記述します。拡張子 *.mm は、Objective-C 及び C++ を混在しても問題なく動作します。\n\n```\n// NativeLauncher.mm\n\n#include \"NativeLauncher.h\"\n#include \"AppController.h\"\n\nvoid NativeLauncher::launchNative()\n{\n    AppController *appController = (AppController *)[UIApplication sharedApplication].delegate;\n    [appController launchNative];\n}\n```\n\n以上で、Xcode からビルドを行うと iOS アプリが起動します。cocos2d-x から Objective-C のコードが実行できるのが確認できます。\n\n## Android 側で行う作業（Eclipse）\n\n基本的に、Android も iOS と同じ手順を踏みますが、Java のコードを実行する際に、JNI を実装する必要があります。JNI とは、Java と C/C++ を連携する機能のことです。\n\nプロジェクト名/proj.android を Eclipse で起動します。src/パッケージ名/プロジェクト名.java にログを吐き出すだけのメソッドを追加します。ここでのプロジェクト名は MyProject です。\n\n```\n// MyProject.java\n\npublic class MyProject extends Cocos2dxActivity{\n\t\n    // …\n    \n    public static void launchNative()\n    {\n        System.out.println(\"launchNative()\");\n    }\n\n    // …\n}\n```\n\nこちらを cocos2d-x から呼び出すために、NativeLauncher.cpp を作成し、以下の内容を記述します。CLASS_NAME は、パッケージ名と Java クラス名をスラッシュで区切った文字列になります。\n\n```\n// NativeLauncher.cpp\n\n#include \"NativeLauncher.h\"\n#include <jni.h>\n#include \"platform/android/jni/JniHelper.h\"\n// パッケージ名と Java クラス名\n#define CLASS_NAME \"com/rakuishi/myproject/MyProject\"\n\nvoid NativeLauncher::launchNative()\n{\n\tcocos2d::JniMethodInfo t;\n\tif (cocos2d::JniHelper::getStaticMethodInfo(t, CLASS_NAME, \"launchNative\", \"()V\")) {\n\t\tt.env->CallStaticVoidMethod(t.classID, t.methodID);\n\t\tt.env->DeleteLocalRef(t.classID);\n\t}\n}\n```\n\nまた、.cpp ファイルを追加したので、Eclipse のビルドに含めるように明示する必要があります。Android.mk に以下の内容を記述します。\n\n```\nLOCAL_SRC_FILES := hellocpp/main.cpp \\\n                   ../../Classes/AppDelegate.cpp \\\n                   ../../Classes/HelloWorldScene.cpp \\\n                   ../../Classes/NativeLauncher.cpp\n```\n\nまた、Xcode でファイルを追加したのに Eclipse で表示されないなどの場合は、[File] → [Refresh] を選択すると正しく表示されます。\n\n以上で、Eclipse からビルドを行うと Android アプリが起動します。cocos2d-x から Java のコードが実行できるのが確認できます。\n\n## 参考\n\n[cocos2d-xからブラウザを起動する方法(iOS, Android) | チラ裏開発メモ](http://tks2.net/memo/?p=74)",
  "bodyHtml": "<p>マルチプラットフォーム開発できる cocos2d-x で、iOS の Objective-C、Android の Java のコードを実行する方法を紹介します。</p>\n<p>ここでは、ログを出力させるコードをネイティブで書きます。ログを出力するコードは、iOS なら AppController.m、Android なら MyProject.java に記述し、それをコールする処理を想定しています。</p>\n<h2>作成するファイル</h2>\n<p>以下のファイルを プロジェクト名/Classes に作成します。</p>\n<ul>\n<li>NativeLauncher.h（iOS, Android 共通）</li>\n<li>NativeLauncher.mm（iOS）</li>\n<li>NativeLauncher.cpp（Android）</li>\n</ul>\n<p><img src=\"/images/2013/08/5817_1.png\" alt=\"\"></p>\n<h2>iOS 及び Android 共通の作業</h2>\n<p>NativeLauncher.h を作成し、以下の内容を記述します。返り値 void で、引数を必要としない launchNative() クラスを宣言します。</p>\n<pre><code>// NativeLauncher.h\n\n#ifndef MyProject_NativeLauncher_h\n#define MyProject_NativeLauncher_h\n\nclass NativeLauncher\n{\npublic:\n    static void launchNative();\n};\n\n#endif\n</code></pre>\n<p>NativeLauncher.h で宣言したクラスを HelloWorldScene.cpp から呼び出すように追加します。標準で作成される HelloWorldScene.cpp の menuCloseCallback に記述します。これで、ボタンが押されるたびにログが吐かれるようになります。</p>\n<pre><code>// HelloWorldScene.cpp\n\nvoid HelloWorld::menuCloseCallback(CCObject* pSender)\n{\n    NativeLauncher::launchNative();\n    \n    /*\n    CCDirector::sharedDirector()-&gt;end();\n\n#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\n    exit(0);\n#endif\n     */\n}\n</code></pre>\n<h2>iOS 側で行う作業（Xcode）</h2>\n<p>プロジェクト名/proj.ios/プロジェクト名.xcodeproj を Xcode で起動します。</p>\n<p>AppController.h および AppController.m にログを吐き出すだけのメソッドを追加します。</p>\n<pre><code>// AppController.h\n\n#import &lt;UIKit/UIKit.h&gt;\n\n@class RootViewController;\n\n@interface AppController : NSObject &lt;UIApplicationDelegate&gt; {\n    UIWindow *window;\n    RootViewController    *viewController;\n}\n\n- (void)launchNative; // 追加\n\n@end\n</code></pre>\n<pre><code>// AppController.m\n\n// ...\n\n- (void)launchNative\n{\n    NSLog(@&quot;%s&quot;, __FUNCTION__);\n}\n\n// ...\n</code></pre>\n<p>こちらを cocos2d-x から呼び出すために、NativeLauncher.mm を作成し、以下の内容を記述します。拡張子 *.mm は、Objective-C 及び C++ を混在しても問題なく動作します。</p>\n<pre><code>// NativeLauncher.mm\n\n#include &quot;NativeLauncher.h&quot;\n#include &quot;AppController.h&quot;\n\nvoid NativeLauncher::launchNative()\n{\n    AppController *appController = (AppController *)[UIApplication sharedApplication].delegate;\n    [appController launchNative];\n}\n</code></pre>\n<p>以上で、Xcode からビルドを行うと iOS アプリが起動します。cocos2d-x から Objective-C のコードが実行できるのが確認できます。</p>\n<h2>Android 側で行う作業（Eclipse）</h2>\n<p>基本的に、Android も iOS と同じ手順を踏みますが、Java のコードを実行する際に、JNI を実装する必要があります。JNI とは、Java と C/C++ を連携する機能のことです。</p>\n<p>プロジェクト名/proj.android を Eclipse で起動します。src/パッケージ名/プロジェクト名.java にログを吐き出すだけのメソッドを追加します。ここでのプロジェクト名は MyProject です。</p>\n<pre><code>// MyProject.java\n\npublic class MyProject extends Cocos2dxActivity{\n\t\n    // …\n    \n    public static void launchNative()\n    {\n        System.out.println(&quot;launchNative()&quot;);\n    }\n\n    // …\n}\n</code></pre>\n<p>こちらを cocos2d-x から呼び出すために、NativeLauncher.cpp を作成し、以下の内容を記述します。CLASS_NAME は、パッケージ名と Java クラス名をスラッシュで区切った文字列になります。</p>\n<pre><code>// NativeLauncher.cpp\n\n#include &quot;NativeLauncher.h&quot;\n#include &lt;jni.h&gt;\n#include &quot;platform/android/jni/JniHelper.h&quot;\n// パッケージ名と Java クラス名\n#define CLASS_NAME &quot;com/rakuishi/myproject/MyProject&quot;\n\nvoid NativeLauncher::launchNative()\n{\n\tcocos2d::JniMethodInfo t;\n\tif (cocos2d::JniHelper::getStaticMethodInfo(t, CLASS_NAME, &quot;launchNative&quot;, &quot;()V&quot;)) {\n\t\tt.env-&gt;CallStaticVoidMethod(t.classID, t.methodID);\n\t\tt.env-&gt;DeleteLocalRef(t.classID);\n\t}\n}\n</code></pre>\n<p>また、.cpp ファイルを追加したので、Eclipse のビルドに含めるように明示する必要があります。Android.mk に以下の内容を記述します。</p>\n<pre><code>LOCAL_SRC_FILES := hellocpp/main.cpp \\\n                   ../../Classes/AppDelegate.cpp \\\n                   ../../Classes/HelloWorldScene.cpp \\\n                   ../../Classes/NativeLauncher.cpp\n</code></pre>\n<p>また、Xcode でファイルを追加したのに Eclipse で表示されないなどの場合は、[File] → [Refresh] を選択すると正しく表示されます。</p>\n<p>以上で、Eclipse からビルドを行うと Android アプリが起動します。cocos2d-x から Java のコードが実行できるのが確認できます。</p>\n<h2>参考</h2>\n<p><a href=\"http://tks2.net/memo/?p=74\">cocos2d-xからブラウザを起動する方法(iOS, Android) | チラ裏開発メモ</a></p>\n",
  "dir": "static/content/archives",
  "base": "2013-08-04-5817.json",
  "ext": ".json",
  "sourceBase": "2013-08-04-5817.md",
  "sourceExt": ".md"
}