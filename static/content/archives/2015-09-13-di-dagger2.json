{
  "categories": [
    "Android"
  ],
  "date": "2015-09-13T09:07:04.000Z",
  "draft": false,
  "slug": "di-dagger2",
  "title": "依存性注入（DI: Dependency Injection）と Dagger 2",
  "bodyContent": "依存性注入（DI: Dependency Injection）という単語を知ってはいたけれど、その意味を知らなかったので調べた。また、前に書いた [Todo-Android](https://github.com/rakuishi/Todo-Android) という Android アプリを元に依存性注入を考えた。\n\nAndroid では、Dagger というライブラリが DI を実装するのに有名みたいだ。Square 製の [Dagger](https://github.com/square/dagger) があり、それをフォークした  Google 製の [Dagger 2](https://github.com/google/dagger) がある。開発が盛んである Dagger 2 を使った。\n\n## 依存性注入すると何が解決できそうか\n\nTodo-Android アプリの中では、RealmTodoManager が Todo 情報を管理していて、Todo リストを返したり、Todo の追加・更新・削除を担っている。\n\n    public class RealmTodoManager {\n        public RealmTodoManager() { /* 省略 */ }\n        public Todo find(int id) { /* 省略 */ }\n        public List<Todo> findAll() { /* 省略 */ }\n        public void insert(String name, boolean completed) { /* 省略 */ }\n        public void update(int id, String name, boolean completed) { /* 省略 */ }\n        public void delete(int id) { /* 省略 */ }\n    }\n\nこの RealmTodoManager は、各 Activity でインスタンス化し、使い回している。各 Actiivty は、RealmTodoManager に依存している状態である。\n\nここで開発の途中にデータ管理を Realm から SQLite に変えた時は、SQLiteTodoManager を作成することになるが、各 Activity を全部書き直すことになる。あるいは、Debug ビルドの時は、モックデータを返すようにしたい時に、どのように実装すれば良いのか悩むことになる。\n\nまた、RealmTodoManager をシングルトンにしたい時に各 Activity で書き換えが必要になるし、シングルトンはテストがしにくいから、なるべくなら避けたい気がする。\n\n依存性注入を行うと、このようなもやもやがうまく解消できるようだ。\n\n## Dagger 2 による依存性注入の手順\n\n### Gradle 設定\n\nトップレベルの build.gradle ファイル（Project）に、android-apt の設定を追加する。\n\n    buildscript {\n        repositories {\n            jcenter()\n        }\n        dependencies {\n            classpath 'com.android.tools.build:gradle:1.1.0'\n            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' // 追加\n        }\n    }\n\n    /* 省略 */\n\nアプリケーションの build.gradle ファイル（Module: app）に、以下の設定を追加する。\n\n    apply plugin: 'com.android.application'\n    apply plugin: 'com.neenbedankt.android-apt' // 追加\n\n    /* 省略 */\n\n    dependencies {\n        compile fileTree(dir: 'libs', include: ['*.jar'])\n        compile 'javax.annotation:jsr250-api:1.0' // 追加\n        compile 'com.google.dagger:dagger:2.0.1' // 追加\n        apt 'com.google.dagger:dagger-compiler:2.0.1' // 追加\n    }\n\n### 実装\n\nまずは、TodoManager というインターフェースを宣言する。\n\n    public interface TodoManager {\n        Todo find(int id);\n        List<Todo> findAll();\n        void insert(String name, boolean completed);\n        void update(int id, String name, boolean completed);\n        void delete(int id);\n    }\n\nこのインターフェースを実装した RealmTodoManager を作成する。今後、SQLiteTodoManager を作るときもこのインターフェースを実装する。同様にモックデータを返す MockTodoManager とかも作れる。\n\n    public class RealmTodoManager implements TodoManager {\n        public RealmTodoManager(Context context) { /* 省略 */ }\n        @Override Todo find(int id) { /* 省略 */ }\n        /* 省略 */\n    }\n\nモジュールを作成する。モジュールは、インスタンスを提供（provide）するメソッド群を定義したものである。メソッド名には `provide` を接頭語にする、メソッドは `@Provides` アノテーションを宣言するのが決まりとなっている。\n\n`provideTodoManager()` は、TodoManager を提供する関数。この返り値の型は、TodoManager としているが、実際には RealmTodoManager のインスタンスを返している。今後 SQLiteTodoManager に差し替わった時には、ここの記述を差し替えるだけで良くなる。シングルトンにするかどうかも `@Singleton` アノテーションにより宣言できる。RealmTodoManager 側でシングルトンの設定をする必要がなくなるため、テストコードが書きやすくなる。\n\n    @Module\n    public class PersistenceModule {\n        @Provides @Singleton\n        public TodoManager provideTodoManager() {\n            return new RealmTodoManager();\n        }\n    }\n\n次にコンポーネントを作成する。これは依存性を注入する先と、モジュールの関係性を定義する。ここでは、PersistenceModule が MainActivity に注入できるように宣言する。`modules` と複数形になっていることから察せられるように、複数のモジュールを紐付けることができる。\n\n    @Singleton\n    @Component(modules = PersistenceModule.class)\n    interface PersistenceComponent {\n        void inject(MainActivity activity);\n    }\n\n実際に利用するには、MainActivity の `onCreate()` 内などで `inject` する。この時に、`@Inject` と書かれたメンバ変数に `provide` で記述されたものが注入される。これを「依存性が注入された」と言うみたいだ。ポイントとしては、注入する実態が MainActivity 側から取り除かれているということ。\n\n    public class MainActivity extends BaseActivity {\n        @Inject TodoManager mTodoManager;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            PersistenceComponent component = DaggerPersistenceComponent.create();\n            component.inject(this);\n        }\n    }\n\nちなみに DaggerPersistenceComponent だが、これは PersistenceComponent のビルド後に作成される。\n\n## 参考\n\n* [要するに DI って何なのという話 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く](http://nekogata.hatenablog.com/entry/2014/02/13/073043)\n* [例えば, Singleton を避ける - Born Too Late](http://blog.yuyat.jp/archives/1500)\n* [Dagger ‡ A fast dependency injector for Android and Java.](http://google.github.io/dagger/)\n* [frogermcs/DaggerExample](https://github.com/frogermcs/DaggerExample)\n* [LiveTyping/u2020-mvp](https://github.com/LiveTyping/u2020-mvp)",
  "bodyHtml": "<p>依存性注入（DI: Dependency Injection）という単語を知ってはいたけれど、その意味を知らなかったので調べた。また、前に書いた <a href=\"https://github.com/rakuishi/Todo-Android\">Todo-Android</a> という Android アプリを元に依存性注入を考えた。</p>\n<p>Android では、Dagger というライブラリが DI を実装するのに有名みたいだ。Square 製の <a href=\"https://github.com/square/dagger\">Dagger</a> があり、それをフォークした  Google 製の <a href=\"https://github.com/google/dagger\">Dagger 2</a> がある。開発が盛んである Dagger 2 を使った。</p>\n<h2>依存性注入すると何が解決できそうか</h2>\n<p>Todo-Android アプリの中では、RealmTodoManager が Todo 情報を管理していて、Todo リストを返したり、Todo の追加・更新・削除を担っている。</p>\n<pre><code>public class RealmTodoManager {\n    public RealmTodoManager() { /* 省略 */ }\n    public Todo find(int id) { /* 省略 */ }\n    public List&lt;Todo&gt; findAll() { /* 省略 */ }\n    public void insert(String name, boolean completed) { /* 省略 */ }\n    public void update(int id, String name, boolean completed) { /* 省略 */ }\n    public void delete(int id) { /* 省略 */ }\n}\n</code></pre>\n<p>この RealmTodoManager は、各 Activity でインスタンス化し、使い回している。各 Actiivty は、RealmTodoManager に依存している状態である。</p>\n<p>ここで開発の途中にデータ管理を Realm から SQLite に変えた時は、SQLiteTodoManager を作成することになるが、各 Activity を全部書き直すことになる。あるいは、Debug ビルドの時は、モックデータを返すようにしたい時に、どのように実装すれば良いのか悩むことになる。</p>\n<p>また、RealmTodoManager をシングルトンにしたい時に各 Activity で書き換えが必要になるし、シングルトンはテストがしにくいから、なるべくなら避けたい気がする。</p>\n<p>依存性注入を行うと、このようなもやもやがうまく解消できるようだ。</p>\n<h2>Dagger 2 による依存性注入の手順</h2>\n<h3>Gradle 設定</h3>\n<p>トップレベルの build.gradle ファイル（Project）に、android-apt の設定を追加する。</p>\n<pre><code>buildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.1.0'\n        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' // 追加\n    }\n}\n\n/* 省略 */\n</code></pre>\n<p>アプリケーションの build.gradle ファイル（Module: app）に、以下の設定を追加する。</p>\n<pre><code>apply plugin: 'com.android.application'\napply plugin: 'com.neenbedankt.android-apt' // 追加\n\n/* 省略 */\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'javax.annotation:jsr250-api:1.0' // 追加\n    compile 'com.google.dagger:dagger:2.0.1' // 追加\n    apt 'com.google.dagger:dagger-compiler:2.0.1' // 追加\n}\n</code></pre>\n<h3>実装</h3>\n<p>まずは、TodoManager というインターフェースを宣言する。</p>\n<pre><code>public interface TodoManager {\n    Todo find(int id);\n    List&lt;Todo&gt; findAll();\n    void insert(String name, boolean completed);\n    void update(int id, String name, boolean completed);\n    void delete(int id);\n}\n</code></pre>\n<p>このインターフェースを実装した RealmTodoManager を作成する。今後、SQLiteTodoManager を作るときもこのインターフェースを実装する。同様にモックデータを返す MockTodoManager とかも作れる。</p>\n<pre><code>public class RealmTodoManager implements TodoManager {\n    public RealmTodoManager(Context context) { /* 省略 */ }\n    @Override Todo find(int id) { /* 省略 */ }\n    /* 省略 */\n}\n</code></pre>\n<p>モジュールを作成する。モジュールは、インスタンスを提供（provide）するメソッド群を定義したものである。メソッド名には <code>provide</code> を接頭語にする、メソッドは <code>@Provides</code> アノテーションを宣言するのが決まりとなっている。</p>\n<p><code>provideTodoManager()</code> は、TodoManager を提供する関数。この返り値の型は、TodoManager としているが、実際には RealmTodoManager のインスタンスを返している。今後 SQLiteTodoManager に差し替わった時には、ここの記述を差し替えるだけで良くなる。シングルトンにするかどうかも <code>@Singleton</code> アノテーションにより宣言できる。RealmTodoManager 側でシングルトンの設定をする必要がなくなるため、テストコードが書きやすくなる。</p>\n<pre><code>@Module\npublic class PersistenceModule {\n    @Provides @Singleton\n    public TodoManager provideTodoManager() {\n        return new RealmTodoManager();\n    }\n}\n</code></pre>\n<p>次にコンポーネントを作成する。これは依存性を注入する先と、モジュールの関係性を定義する。ここでは、PersistenceModule が MainActivity に注入できるように宣言する。<code>modules</code> と複数形になっていることから察せられるように、複数のモジュールを紐付けることができる。</p>\n<pre><code>@Singleton\n@Component(modules = PersistenceModule.class)\ninterface PersistenceComponent {\n    void inject(MainActivity activity);\n}\n</code></pre>\n<p>実際に利用するには、MainActivity の <code>onCreate()</code> 内などで <code>inject</code> する。この時に、<code>@Inject</code> と書かれたメンバ変数に <code>provide</code> で記述されたものが注入される。これを「依存性が注入された」と言うみたいだ。ポイントとしては、注入する実態が MainActivity 側から取り除かれているということ。</p>\n<pre><code>public class MainActivity extends BaseActivity {\n    @Inject TodoManager mTodoManager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        PersistenceComponent component = DaggerPersistenceComponent.create();\n        component.inject(this);\n    }\n}\n</code></pre>\n<p>ちなみに DaggerPersistenceComponent だが、これは PersistenceComponent のビルド後に作成される。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"http://nekogata.hatenablog.com/entry/2014/02/13/073043\">要するに DI って何なのという話 - 猫型の蓄音機は 1 分間に 45 回にゃあと鳴く</a></li>\n<li><a href=\"http://blog.yuyat.jp/archives/1500\">例えば, Singleton を避ける - Born Too Late</a></li>\n<li><a href=\"http://google.github.io/dagger/\">Dagger ‡ A fast dependency injector for Android and Java.</a></li>\n<li><a href=\"https://github.com/frogermcs/DaggerExample\">frogermcs/DaggerExample</a></li>\n<li><a href=\"https://github.com/LiveTyping/u2020-mvp\">LiveTyping/u2020-mvp</a></li>\n</ul>\n",
  "dir": "static/content/archives",
  "base": "2015-09-13-di-dagger2.json",
  "ext": ".json",
  "sourceBase": "2015-09-13-di-dagger2.md",
  "sourceExt": ".md"
}